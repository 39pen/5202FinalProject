import dash
from dash import dcc, callback, html, State, callback_context
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import pandas as pd
import io
import base64
from datetime import datetime
import tabulate
import plotly.express as px
import plotly.graph_objs as go



#æ–°å¢ï¼šcluster analysisæ‰€éœ€è¦çš„å®‰è£…åŒ…
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.cluster import KMeans
from dash.exceptions import PreventUpdate
from dash import dash_table
from dash.dash_table.Format import Format 
import plotly.graph_objs as go
from dash import no_update

card_content_a = [
    dbc.CardHeader(
        [
            html.Div([
                html.H1(id="num-games"),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
    dbc.CardFooter(
        [
            html.Div([html.I(className="bi bi-controller"), "Number of Games"], className="text-center"),
        ]
    ),
]

card_content_b = [
    dbc.CardBody(
        [
            html.H1(id="num-genres", className="text-center"),
        ],
    ),
    dbc.CardFooter(
        [
            html.Div([html.I(className="bi bi-tags-fill"), "Number of Genres"], className="text-center"),
        ]
    ),
]

card_content_c = [
    dbc.CardHeader(
        [
            html.Div([
                html.H1(id="unique-developers"),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
    dbc.CardFooter(
        [
            html.Div([html.I(className="bi bi-code-square"), "Number of Developers"], className="text-center"),
        ]
    ),
]

card_content_d = [
    dbc.CardHeader(
        [
            html.Div([html.I(className="bi bi-collection-play-fill"), "Average Plays"], className="text-center"),
        ]
    ),
    dbc.CardBody(
        [
            html.Div([
                html.H1(id="avg-plays"),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
]
card_content_e = [
    dbc.CardBody(
        [
            html.Div([
                html.H1(id="avg-rating", style={'color': 'white'}),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
    dbc.CardFooter(
        [
            html.Div([html.I(className="bi bi-star"), "Average Rating"], className="text-center"),
        ]
    ),
]
card_content_f = [
    dbc.CardHeader(
        [
            html.Div([html.I(className="bi bi-chat-left-text-fill"), "Number of Descriptions"], className="text-center"),
        ]
    ),
    dbc.CardBody(
        [
            html.Div([
                html.H1(id="num-description"),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
]

# Define the cards of Feedback 
# Define the card style with rounded corners and shadows
card_style_a = {
    'backgroundColor': 'rgba(94, 114, 228, 0.75)',  # Semi-transparent blue background
    'boxShadow': '0 4px 8px rgba(0, 0, 0, 0.15)',  # Subtle shadow
    'borderRadius': '0.5rem',  # Rounded corners
    'marginBottom': '20px',  # Space between cards
    'overflow': 'hidden',  # Prevents content from spilling out
    'display': 'flex',  # Enables flexbox
    'flexDirection': 'column',  # Stack children vertically
    'justifyContent': 'center',  # Center vertically
    'alignItems': 'center'  # Center horizontally
}

card_style_b = {
    'backgroundColor': 'rgba(94, 114, 228, 0.25)',  # Semi-transparent blue background
    'boxShadow': '0 4px 8px rgba(0, 0, 0, 0.15)',  # Subtle shadow
    'borderRadius': '0.5rem',  # Rounded corners
    'marginBottom': '20px',  # Space between cards
    'overflow': 'hidden',  # Prevents content from spilling out
    'display': 'flex',  # Enables flexbox
    'flexDirection': 'column',  # Stack children vertically
    'justifyContent': 'center',  # Center vertically
    'alignItems': 'center'  # Center horizontally
}


# First card with consistent style
card_a = dbc.Card([
    dbc.CardBody([
        html.H1(id="unique-developers-output", className="text-center", style={'marginTop':'10px'})
    ])
], style=card_style_a)

# Second card with consistent style
card_b = dbc.Card([
    dbc.CardBody([
        html.H1(id="top-developer-output", className="text-center", style={'marginTop':'10px'})
    ])
], style=card_style_b)


#-------------------------------------------------------------------------------------------------------


filter_bar = html.Div([
        dbc.Select(
            id='time-series-selection',
            options=[
                {'label': 'Number of Games Released', 'value': 'Number_of_games'},
                {'label': 'Total Plays', 'value': 'Total_plays'},
                {'label': 'Average Rating', 'value': 'Average_rating'},
                {'label': 'Rank of Genre', 'value': 'Rank_of_Genre'}
            ],
            value='Number_of_games',  # Set the default value
            className='my-2',  # Maintain the margin
            html_size="lg",  # Make the select larger to match other inputs
        )
],className="mb-4")



genre_checklist = html.Div([
    dbc.Label("Select Genres: (After selecting, result show below â¬‡ï¸)"),
    dcc.Checklist(
        id='genre-checklist',
        options=[],  # Initially empty
        value=[],    # Initially empty
        inline=True
    )
], className="mb-3")  # You can adjust className for styling as per your needs


enter_year = html.Div(
            [
                html.P("Enter Year:"),
                dcc.Input(
                    id='year-input',
                    type='number',
                    value=2000,
                    min=1900,
                    max=datetime.now().year,
                    step=1
                )
            ],
            id='input-container',
            style={'display': 'None'},  # Initially invisible 
    className="mb-4")  # Add a bottom margin

#---------------------------------------------------------------------------------------------------------




filter_bar_angle = dbc.CardGroup(
    [
        dbc.Label("Select Angle:", html_for="dropdown"),
        dbc.Select(
            id='angle-selector',
            options=[
                {'label': 'Genre', 'value': 'genre'},
                {'label': 'Platform', 'value': 'platform'}
            ],
            value='genre',  # Default selection
            className='mb-3',  # Margin bottom for spacing
        ),
    ]
)

filter_bar_metric = dbc.CardGroup(
    [
        dbc.Label("Select Metric:", html_for="dropdown"),
        dbc.Select(
            id='metric-selector',
            options=[
                {'label': 'Rating', 'value': 'rating'},
                {'label': 'Plays', 'value': 'plays'},
                {'label': 'Reviews', 'value': 'reviews'}
            ],
            value='rating',  # Default selection
            className='mb-3',  # Margin bottom for spacing
        ),
    ]
)

layout_section = dbc.Row(
    [
        dbc.Col(filter_bar_angle, width=6),
        dbc.Col(filter_bar_metric, width=6)
    ],
    className='my-3'  # Margin top and bottom for the entire row
)

feedback_tab_content = [
    layout_section,  # Your existing filter bar or other setup content

    # Single row for the graphs and the details
    dbc.Row([
        # Column for the first graph and its related information
        dbc.Col([
            dcc.Graph(
                id='distribution-bar-chart', 
                style={
                    'minWidth': '100%',
                    'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)',  # Adding light shadow for card effect
                    'padding': '20px',  # Optional: adds space inside the div container for aesthetic purposes
                    'background': 'white'  # Ensuring the background is white for consistency
                }
            ),
            html.Hr(),  # Horizontal line for visual separation
            dbc.Col(card_a), 
            dbc.Col(card_b)
        ], width=4, className='pe-2'),  # This takes up a third of the row, adding padding on the right for separation

        # Column for the second graph
        dbc.Col([
            dcc.Graph(
                id='distribution-metrics-chart',
                style={
                    'minWidth': '100%',
                    'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)',  # Adding light shadow for card effect
                    'padding': '10px',  # Optional: adds space inside the div container for aesthetic purposes
                    'background': 'white'  # Ensuring the background is white for consistency
                }
            ),
            html.Hr(),  # Horizontal line for visual separation
            # Use a Card to enclose the metrics output
            dbc.Col(id='top-developer-metric-output')
        ], width=4, className='pe-2'),  # This takes up a third of the row, add

        # Column for detailed textual information
        dbc.Col(html.Div([
            html.Div([
                # Merged content
                html.Div(id='top-details', style={'padding': '5px'}),
            ], style={
                'overflow-y': 'auto',  # Enable vertical scrolling within this div
                'height': '765px'  # Set to match graph height
            })
        ], style={
            'height': '785px',  # Same height as the graph
            'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)',  # Adding shadow
            'borderRadius': '1rem',  # Rounded corners
            'padding': '10px',
            'backgroundColor': 'rgba(94, 114, 228, 0.25)'  # Primary color with 50% transparency
        }), width=4, className='g-0')  # Adjust width to match combined width of the left columns
    ], className='g-0 mx-0')  # Use 'g-0' to remove gutters completely, 'mx-0' to remove horizontal margins
]




app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP, dbc.icons.BOOTSTRAP])

app.layout = dbc.Container(children=[
    # åŒ…è£¹åœ¨è“è‰²èƒŒæ™¯ä¸­çš„éƒ¨åˆ†
    html.Div([
        html.H1('Games Dashboard', className='text-white', style={'textAlign': 'center'}),
        
        # æ–°å¢ï¼šUploadæç¤ºå’ŒUploadæŒ‰é’®çš„å®¹å™¨
        html.Div(
            style={'display': 'flex', 'alignItems': 'center', 'justifyContent': 'space-between', 'backgroundColor': '#5e72e4', 'color': 'white'},
            children=[
        # å·¦ä¾§ï¼šUploadæç¤ºå’ŒUploadæŒ‰é’®çš„å®¹å™¨
                html.Div(
                    style={'display': 'flex', 'alignItems': 'center'},
                    children=[
                        # Upload button
                        dcc.Upload(
                            id='upload-data',
                            children=dbc.Button('Choose File', color="primary", className='me-2 shadow-sm', style={'fontWeight': 'bold', 'marginTop': '10px'}),
                            multiple=False  # Restrict to single file upload
                        ),
                        # Uploadæç¤ºæ–‡å­—
                        html.Div(id='data-summary-text', style={'fontWeight': 'bold', 'marginLeft': '15px', 'marginTop': '-5px'})
                    ]
                ),

                html.Div(
                    style={'display': 'flex', 'alignItems': 'center'},
                    children=[

                        # ä¸­é—´ï¼šæ–‡æœ¬æç¤ºé€‰æ‹©æ—¶é—´æ®µ
                        html.Div(
                            style={'fontWeight': 'bold', 'marginRight': '15px', 'marginTop': '-5px'},
                            children="Select the time period you want to analyse: "
                        ),
                        
                        # å³ä¾§ï¼šæ—¥æœŸé€‰æ‹©å™¨
                        dcc.DatePickerRange(
                            id='date-picker-range',
                            display_format='YYYY-MM-DD',
                            start_date='1900-01-01',  # è®¾ç½®é»˜è®¤å¼€å§‹æ—¥æœŸä¸º 1900-01-01
                            end_date=datetime.today().strftime('%Y-%m-%d'),  # è®¾ç½®é»˜è®¤ç»“æŸæ—¥æœŸä¸ºä»Šå¤©çš„æ—¥æœŸ
                            style={'borderRadius': '5px', 'border': 'none'}
                        )
                    ]
                )
    ]
),

    ], style={'backgroundColor': '#5e72e4', 'padding': '20px'}),

    
    
    #------------------------------------------------------------------------------------------------
    
    # åœ¨ app.layout å†…éƒ¨æ·»åŠ 
    dcc.Store(id='genre-list-store'),
    
    

    #-------------------------------------------------------------------------------------------------
    

    # ä¸»è¦å†…å®¹åŒºåŸŸï¼ŒèƒŒæ™¯ä¸ºç™½è‰²
    html.Div([
        dcc.Tabs(id="tabs", children=[
            dcc.Tab(label='Overview', children=[  
                html.Div([  # Container for cards with padding
                    dbc.Row(
                        [
                            dbc.Col(dbc.Card(card_content_a, color="primary", inverse=True)),
                            dbc.Col(dbc.Card(card_content_b, color="primary", outline=True)),
                            dbc.Col(dbc.Card(card_content_c, color="primary", inverse=True)),
                        ],
                        className="mb-4",  # Margin bottom for spacing between rows
                    ),
                    dbc.Row(
                        [
                            dbc.Col(dbc.Card(card_content_d, color="primary", outline=True)),
                            dbc.Col(dbc.Card(card_content_e, color="primary", inverse=True)),
                            dbc.Col(dbc.Card(card_content_f, color="primary", outline=True)),
                        ],
                        className="mb-4",  # Increase margin bottom if needed
                    ),
                ], style={'paddingTop': '30px'}),

                dbc.Row(
                    style={'marginTop': '30px', 'textAlign': 'center'},
                    children=[html.H2("Time Series Analysis")],
                ),

                # æ–°å¢ï¼šfilter bar
                filter_bar,
                
                #-----------------------------------------------------------------------------------------
                genre_checklist,
                
                enter_year,

                #-----------------------------------------------------------------------------------------


                
                # ç”¨äºæ˜¾ç¤ºæ—¶é—´åºåˆ—å›¾è¡¨çš„container
                dbc.Row(id='time-series-chart', style={'width': '100%', 'marginTop': '20px'}),


            ]),

            dcc.Tab(label='Relationship', children=[
                dbc.Row([
                    dbc.Col(html.Div(id='reviews-rating-chart', style={'marginTop': '10px'}), width=6),
                    dbc.Col(html.Div(id='plays-playing-chart', style={'marginTop': '10px'}), width=6),
                ]),
                dbc.Row([
                    dbc.Col(dcc.Graph(id='rating-comparison-chart'), width=12),
                ])
            ]),

            dcc.Tab(label='Feedback', children=feedback_tab_content),

            dcc.Tab(label='Recommendation', children=[
                # Search bar
                html.Div(
                    style={'display': 'flex', 'justifyContent': 'flex-start', 'marginRight': '10px', 'marginTop': '20px', 'flexGrow': '1'},
                    children=[
                        dbc.Input(id='search-bar', type='text', placeholder='Search for a game...', className='me-1', style={'width': '1250px', 'height': '50px'}),
                        html.Div(  # å†…éƒ¨å®¹å™¨ï¼Œç”¨äºæ›´çµæ´»åœ°æ§åˆ¶æœç´¢æŒ‰é’®çš„ä½ç½®
                            style={'marginLeft': '20px', 'alignSelf': 'flex-start'},  # æ§åˆ¶å†…éƒ¨æŒ‰é’®çš„å·¦è¾¹è·å’Œå‚ç›´å¯¹é½
                            children=[
                                dbc.Button('Search', id='search-button', n_clicks=0, color="primary", className='me-2 shadow-sm', style={'fontWeight': 'bold', 'marginTop': '3px'}),
                            ])]
                ),
                html.Div(id='game-details-output', style={'marginTop': '20px'})
            ]),
        ]),
    ], style={'backgroundColor': 'white'}),  # è®¾ç½®æ•´ä¸ªå†…å®¹åŒºåŸŸèƒŒæ™¯è‰²ä¸ºç™½è‰²
])

@app.callback(
    Output('date-picker-range', 'start_date'),
    [Input('upload-data', 'contents')]
)
def update_date_range(contents):
    if contents is None:
        # Return the default start date if no file is uploaded
        return '1900-01-01'
    
    # Decode the uploaded file content
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
    
    # Convert 'date' column to datetime
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    
    # Get the minimum date from the 'date' column
    min_date = df['date'].min()
    
    # Check if min_date is NaT (not a time), then return default, otherwise return min_date
    return min_date if pd.notna(min_date) else '1900-01-01'


# Callback to update the graph based on the uploaded file
@app.callback(
    [Output('data-summary-text', 'children'),
     Output('num-games', 'children'),
     Output('num-genres', 'children'),
     Output('unique-developers', 'children'),
     Output('avg-plays', 'children'),
     Output('avg-rating', 'children'),
     Output('num-description', 'children')],
    
    [Input('upload-data', 'contents'),
     Input('upload-data', 'filename'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date')] 
    
)

def update_summary(content, filename, start_date, end_date):

    # Initial placeholders for the statistics
    num_games = num_genres = unique_developers = avg_plays = avg_rating = num_description = 'N/A'
    
    
    if content is None:
        return 'Upload a file to start the analysis.', num_games, num_genres, unique_developers, avg_plays, avg_rating, num_description

    # Decode the uploaded file
    content_type, content_string = content.split(',')
    decoded = io.StringIO(base64.b64decode(content_string).decode('utf-8'))
    df = pd.read_csv(decoded)
    # Give a summary of the file
    summary_text = f'The file {filename} has been uploaded.'

    # Filter according to date selection
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    filtered_df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))]
    # Overview of data within the selected date range
    num_games = len(filtered_df)
    num_genres = filtered_df['genre'].nunique()
    unique_developers = filtered_df['developer'].nunique()
    avg_plays = round(filtered_df['plays'].mean(), 2)
    avg_rating = round(filtered_df['rating'].mean(), 2)
    num_description = filtered_df['description'].notna().sum()

    
    return summary_text, num_games, num_genres, unique_developers, avg_plays, avg_rating, num_description


# ----------ä»¥ä¸‹ä¸ºæ›´æ–°-------------------------------------------------------------------------------------------


@app.callback(
    Output('genre-list-store', 'data'),
    [Input('upload-data', 'contents')]
)
def update_genre_list(contents):
    if contents is None:
        raise PreventUpdate

    # è§£æä¸Šä¼ çš„æ–‡ä»¶å†…å®¹
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # 'genre' åˆ—ä¸­çš„æ¯ä¸ªæ¡ç›®åŒ…å«å¤šä¸ªç”¨é€—å·åˆ†éš”çš„ç±»å‹
    genres = set()
    for genre_list in df['genre'].dropna().unique():
        genres.update([genre.strip() for genre in genre_list.split(',')])
    
    # è¿”å›æ‰€æœ‰å”¯ä¸€çš„æ¸¸æˆç±»å‹
    return list(genres)


@app.callback(
    Output('genre-checklist', 'options'),
    [Input('genre-list-store', 'data')]
)
def set_checklist_options(genres):
    if not genres:
        return []
    # ç¡®ä¿é€‰é¡¹æŒ‰å­—æ¯é¡ºåºæ’åºï¼Œä»¥ä¾¿ç”¨æˆ·å®¹æ˜“æŸ¥æ‰¾
    return [{'label': genre, 'value': genre} for genre in sorted(genres)]


@app.callback(
    [
    Output('time-series-chart', 'children'),
    Output('input-container', 'style'),  # Control visibility of the input container
    
    ],
    [Input('upload-data', 'contents'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('time-series-selection', 'value'),
     Input('genre-checklist', 'value'), # æ¥æ”¶checklistçš„è¾“å…¥
     Input('year-input', 'value')  # Include the year from the input box
    
] 
)


def update_time_series_chart(contents, start_date, end_date, time_series_selection, genres, year):
    if contents is None:
        raise PreventUpdate

     
    
    # Handling time series selections
    if time_series_selection != 'Rank_of_Genre':
        graphs = []
    
        # Parse uploaded file
        content_type, content_string = contents.split(',')
        decoded = base64.b64decode(content_string)
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

        # Filter according to date selection
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        filtered_df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))]

        # Check if filtered_df is empty
        if filtered_df.empty:
            return [html.Div("No data available for the selected date range.")], {'display': 'none'}

        
        
        # Calculate the length of the date range
        start_year = pd.to_datetime(start_date).year
        end_year = pd.to_datetime(end_date).year

        resample_code = 'Y' if start_year != end_year else 'M'
        title_suffix = 'Year' if start_year != end_year else 'Month'
        title = lambda field: f'{field} per {title_suffix} Over Time (All Games)'
        title2 = lambda field: f'{field} per {title_suffix} Over Time (Specific Genres)'
        
        

        field = 'plays' if time_series_selection == 'Total_plays' else 'rating' if time_series_selection == 'Average_rating' else None
        operation = 'sum' if time_series_selection == 'Total_plays' else 'mean' if time_series_selection == 'Average_rating' else 'size'
        aggregated_data = filtered_df.resample(resample_code, on='date')[field].agg(operation) if field else filtered_df.resample(resample_code, on='date').size()
        
        if not aggregated_data.empty:
            aggregated_data.index = aggregated_data.index.to_period(resample_code).start_time
            fig = go.Figure()
            fig.add_trace(go.Scatter(x=aggregated_data.index, y=aggregated_data, mode='lines+markers', name='All Games'))
            fig.update_layout(
                title=title(time_series_selection.replace('_', ' ').title()),
                xaxis_title='Date',
                yaxis_title=time_series_selection.replace('_', ' ').title()
            )

            # Adjusting x-axis tick format
            tickformat = "%Y" if resample_code == 'Y' else "%Y-%m"
            fig.update_xaxes(dtick="M12" if resample_code == 'Y' else "M1", tickformat=tickformat)
            fig.update_xaxes(tickfont=dict(size=8))
            
            graphs.append(dcc.Graph(figure=fig))    

        if genres:
            
            fig2 = go.Figure()
            data_available = False

            for genre in genres:
                genre_df = filtered_df[filtered_df['genre'].str.contains(genre, case=False, na=False)]

                if not genre_df.empty:
                    
                    genre_specific_data = genre_df.resample(resample_code, on='date')[field].agg(operation) if field else genre_df.resample(resample_code, on='date').size()
                    
                    if not genre_specific_data.empty:
                        
                        genre_specific_data.index = genre_specific_data.index.to_period(resample_code).start_time

                        fig2.add_trace(go.Scatter(x=genre_specific_data.index, y=genre_specific_data, mode='lines+markers', name=f'Games in {genre}'))
                        data_available = True  # è‡³å°‘æœ‰ä¸€ä¸ªgenreæœ‰æ•°æ®

                        
            if not fig2.data:
                graphs.append(html.Div("No sufficient data available for any selected genres."))
            else:
                fig2.update_layout(title=title2(time_series_selection.replace('_', ' ').title()), xaxis_title='Date', yaxis_title=time_series_selection.replace('_', ' '), showlegend=True)
                fig2.update_layout(legend=dict(font=dict(size=8)))
                # Adjusting x-axis tick format
                tickformat = "%Y" if resample_code == 'Y' else "%Y-%m"
                fig2.update_xaxes(dtick="M12" if resample_code == 'Y' else "M1", tickformat=tickformat)
                fig2.update_xaxes(tickfont=dict(size=8))                
                
                graphs.append(dcc.Graph(figure=fig2))

        #return graphs 
            pass


                         
                               
    if time_series_selection == 'Rank_of_Genre':
        # Specifically handling the "Rank of Genre" selection
        content_type, content_string = contents.split(',')
        decoded = base64.b64decode(content_string)
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        # Filter according to date selection
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date)) & (df['date'].dt.year == year)]  # Filter data for the selected year

        # Calculate the length of the date range
        start_year = pd.to_datetime(start_date).year
        end_year = pd.to_datetime(end_date).year
        
        
        # Explode genre column to handle multiple genres per game
        df['genre'] = df['genre'].str.split(', ')
        df = df.explode('genre')

        # Count unique genres for the title
        unique_genres = df['genre'].nunique()

        # Group by genre and calculate metrics
        df['genre'] = df['genre'].fillna('Unknown')  # Replace NaN with a placeholder if appropriate

        games_count = df['genre'].value_counts().reset_index(name='Game Count')
        total_plays = df.groupby('genre')['plays'].sum().reset_index(name='Total Plays')
        average_rating = df.groupby('genre')['rating'].mean().reset_index(name='Average Rating')


        # Ensure an outer join to keep all genres
        summary_df = games_count.merge(total_plays, on='genre', how='outer')\
                                .merge(average_rating, on='genre', how='outer')

        # Handle missing values after the merge
        summary_df.fillna({'Game Count': 0, 'Total Plays': 0, 'Average Rating': 'No Rating'}, inplace=True)

        # Calculate rankings with handling of missing values
        summary_df = summary_df[summary_df['genre'] != 'Unknown']

        summary_df['Game Count Rank'] = summary_df['Game Count'].rank(method='min', ascending=False)
        summary_df['Total Plays Rank'] = summary_df['Total Plays'].rank(method='min', ascending=False)
        summary_df['Average Rating Rank'] = summary_df['Average Rating'].replace('No Rating', np.nan).rank(method='min', ascending=True)
        
        # After calculating rankings, sort by 'Average Rating Rank'
        # Note: We'll use ascending order since a lower rank number means a better rank
        summary_df.sort_values(by='Average Rating Rank', ascending=True, inplace=True)



        # Highlight selected genres
        summary_df['Selected'] = summary_df['genre'].apply(lambda x: 'gold' if x in genres else 'white')
        
        if year < start_year or year > end_year:
            graphs=html.Div(f'{year} is out of your selected date range.')
            
        else:

            # Creating the table with Plotly
            fig = go.Figure(data=[go.Table(
                header=dict(values=['Genre', 'Average Rating Rank', 'Game Count Rank', 'Total Plays Rank']),
                cells=dict(values=[summary_df['genre'], summary_df['Average Rating Rank'], summary_df['Game Count Rank'], summary_df['Total Plays Rank']],
                           fill_color=[summary_df['Selected'], 'white', 'white', 'white'])
            )])
            fig.update_layout(title_text=f"Rank of Genres for the Year {year} (Number of Total Unique Genres: {unique_genres})")


            graphs = [dcc.Graph(figure=fig)]
            
        return graphs, {'display': 'block'}






    return graphs, {'display': 'none'}  # Default return when "Rank of Genre" is not selected

# -----------------------------------------------------------------------------------------------------------------




# Callback to update the searched game data
@app.callback(
    Output('game-details-output', 'children'),
    [Input('search-button', 'n_clicks'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date')],
    [State('search-bar', 'value'),
     State('upload-data', 'contents')]
)

def search_game(n_clicks_search, start_date, end_date, search_value, content):
    ctx = callback_context

    # Determine which button was clicked
    if not ctx.triggered:
        button_id = 'No buttons clicked yet'
    else:
        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
    
    # If the search button was clicked and there's valid input and file content
    if button_id == 'search-button' and n_clicks_search and search_value and content:
        content_type, content_string = content.split(',')
        decoded = base64.b64decode(content_string)
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        df['date'] = pd.to_datetime(df['date'])

        # Normalize case for a case-insensitive full match
        search_value_lower = search_value.lower()
        df['name_lower'] = df['name'].str.lower()

        # Check for a full match rather than a partial match
        match_df = df[df['name_lower'] == search_value_lower]
            
        
        if not match_df.empty:
            # Assuming the first match is the desired one
            game_info = match_df.iloc[0][['name', 'date', 'genre', 'developer', 'platform', 'rating', 'wishlists', 'description']].to_dict()
            #return [html.P(f"{game_info['name']} found")]
            game_details = [
                html.H4(game_info.get('name', 'No Name')),
                html.P(f"Date: {game_info['date'].strftime('%Y-%m-%d') if pd.notna(game_info['date']) else 'No information available'}"),
                html.P(f"Genre: {game_info['genre'] if pd.notna(game_info['genre']) else 'No information available'}"),
                html.P(f"Developer: {game_info['developer'] if pd.notna(game_info['developer']) else 'No information available'}"),
                html.P(f"Platform: {game_info['platform'] if pd.notna(game_info['platform']) else 'No information available'}"),
                html.P(f"Rating: {game_info['rating'] if pd.notna(game_info['rating']) else 'No information available'}"),
                html.P(f"Wishlists: {game_info['wishlists'] if pd.notna(game_info['wishlists']) else 'No information available'}"),
                html.P(f"Description: {game_info['description'] if pd.notna(game_info['description']) else 'No information available'}"),
            ]

            # Exclude the searched game itself from similar game search
            curr_game = game_info['name']
            
            # Filter for games with genre and rating
            no_genre = pd.isna(game_info['genre'])
            no_rating = pd.isna(game_info['rating'])

            if no_genre:
                return game_details + [html.P("Not enough information to find similar games.")]
            
            genre_filter = df['genre'].str.contains(game_info['genre'], case=False, na=False)
            date_filter = (df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))
            relevant_games_df = df[genre_filter & date_filter & (df['name'] != curr_game)]

            game_count = relevant_games_df.shape[0]
            if game_count == 0:
                top_games_details = [html.P("There are no similar games within the selected time frame.")]
                return game_details + top_games_details
            else:
                top_games_df = relevant_games_df.sort_values(by='rating', ascending=False).head(min(5, game_count))
                header_text = f"Top {min(game_count, 5)} games in the same genre and time frame:"
                top_games_details = [html.H5(header_text)]
                top_games_details.extend([
                html.P([
                    game['name'],
                    html.Br(),  # This inserts an actual HTML line break element
                    f"Rating: {game['rating']}"]) for _, game in top_games_df.iterrows()
                ])
                
            if no_rating:
                return game_details + top_games_details
            else:
                # The date and rating of the specific game
                game_rating = game_info['rating']
                game_date = pd.to_datetime(game_info['date'])
                # Take away games with no ratings
                rating_rank_df = relevant_games_df.dropna(subset=['rating'])
                rating_rank_df = pd.concat([rating_rank_df, match_df], ignore_index=True)          
                # Calculate ranks and percentile ranks
                rating_rank_df['rating_rank'] = rating_rank_df['rating'].rank(method='max')  # Use 'max' to handle ties
                rating_rank_df['percentile_rank'] = rating_rank_df['rating_rank'] / len(rating_rank_df) * 100
                # Find the percentile rank for the specific game
                game_percentile = rating_rank_df[rating_rank_df['rating'] == game_rating]['percentile_rank'].max()
                percentile_message = [html.P(f"The rating of {game_info['name']} exceeds {game_percentile:.2f} percent of games for similar games within the selected time frame.")]
                return game_details + top_games_details + percentile_message
            
            
        else:
            # No exact match found
            # Filter for games starting with the search value
            match_df = df[df['name_lower'].str.startswith(search_value_lower)]
            if match_df.shape[0] > 0:
                # Limit to the first 10 games and create a list with each game on a new line
                games_list = match_df['name'].head(10).tolist()
                suggestions = [html.P(f"Are you looking for one of these games?")] + \
                              [html.Div(game) for game in games_list]
                return suggestions
            else:
                no_match_message = html.P("Game information not available.")
                return [no_match_message]
    return []

    
       
    
#æ–°å¢relationship
@app.callback(
    Output('reviews-rating-chart', 'children'),
    [Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_reviews_rating_chart(start_date, end_date, contents):
    if contents is None:
        raise PreventUpdate
    
    # è§£æä¸Šä¼ çš„æ–‡ä»¶
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
    
    # è¿‡æ»¤æ•°æ®é›†ä»¥ç¬¦åˆé€‰æ‹©çš„æ—¥æœŸèŒƒå›´
    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= start_date) & (df['date'] <= end_date)]
    
    # ç”Ÿæˆæ•£ç‚¹å›¾
    fig = px.scatter(filtered_df, x='reviews', y='rating', 
                     title='Relationship between Number of Reviews and Rating',
                     hover_data=['name'])  # æ‚¬åœæ—¶æ˜¾ç¤ºæ¸¸æˆåç§°
    
    # è½¬æ¢å›¾è¡¨ä¸ºHTMLå…ƒç´ 
    graph_html = dcc.Graph(figure=fig)
    
    return graph_html




@app.callback(
    Output('plays-playing-chart', 'children'),
    [Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_plays_playing_chart(start_date, end_date, contents):
    if contents is None:
        raise PreventUpdate
    
    # è§£æä¸Šä¼ çš„æ–‡ä»¶
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
    
    # è¿‡æ»¤æ•°æ®é›†ä»¥ç¬¦åˆé€‰æ‹©çš„æ—¥æœŸèŒƒå›´
    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= start_date) & (df['date'] <= end_date)].copy()
    
    # ç”Ÿæˆæ•£ç‚¹å›¾
    fig = px.scatter(filtered_df, x='plays', y='playing', 
                     title='Relationship between Plays and Playing',
                     hover_data=['name'])  # æ‚¬åœæ—¶æ˜¾ç¤ºæ¸¸æˆåç§°
    
    # è½¬æ¢å›¾è¡¨ä¸ºHTMLå…ƒç´ 
    graph_html = dcc.Graph(figure=fig)
    
    return graph_html


@app.callback(
    Output('rating-comparison-chart', 'figure'),
    [Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_rating_comparison_chart(start_date, end_date, contents):
    if contents is None:
        raise PreventUpdate

    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= start_date) & (df['date'] <= end_date)].copy()

    # Identify the developer category based on inclusion of Sony, Microsoft, or Nintendo
    conditions = [
        filtered_df['developer'].str.contains('Sony', case=False, na=False),
        filtered_df['developer'].str.contains('Microsoft', case=False, na=False),
        filtered_df['developer'].str.contains('Nintendo', case=False, na=False)
    ]
    choices = ['Sony', 'Microsoft', 'Nintendo']
    filtered_df['Developer Category'] = np.select(conditions, choices, default='Others').copy()

    # Plotting the box plot
    fig = px.box(filtered_df, x='Developer Category', y='rating', title='Rating Distribution by Developer Category')

    return fig



@app.callback(
    [Output('distribution-bar-chart', 'figure'),  # å›¾è¡¨æ•°æ®
     Output('distribution-bar-chart', 'style')],  # æ§åˆ¶æ˜¾ç¤ºæ ·å¼
    [Input('angle-selector', 'value'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_distribution_bar_chart(angle, start_date, end_date, contents):
    if contents is None:
        return {}, {'display': 'none'}

    # è§£æä¸Šä¼ çš„æ–‡ä»¶
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # è¿‡æ»¤æ•°æ®é›†ä»¥ç¬¦åˆé€‰æ‹©çš„æ—¥æœŸèŒƒå›´
    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))]

    if angle == 'genre':
        # åˆ†ç±»å¤„ç†å’ŒæŸ±çŠ¶å›¾åˆ¶ä½œ - Genre
        filtered_df['genre'] = filtered_df['genre'].str.split(', ')
        exploded_df = filtered_df.explode('genre')
        specified_genres = ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade']
        exploded_df['genre'] = exploded_df['genre'].apply(lambda x: x if x in specified_genres else 'Others')
        genre_counts = exploded_df['genre'].value_counts().reset_index()
        genre_counts.columns = ['genre', 'count']
        fig = px.bar(genre_counts, x='genre', y='count', title='Genre Distribution')
        return fig, {'display': 'block'}

    elif angle == 'platform':
        # åˆ†ç±»å¤„ç†å’ŒæŸ±çŠ¶å›¾åˆ¶ä½œ - Platform
        filtered_df['platform'] = filtered_df['platform'].str.split(', ')
        exploded_df = filtered_df.explode('platform')
        specified_platforms = ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
        exploded_df['platform'] = exploded_df['platform'].apply(lambda x: x if x in specified_platforms else 'Others')
        platform_counts = exploded_df['platform'].value_counts().reset_index()
        platform_counts.columns = ['platform', 'count']
        fig = px.bar(platform_counts, x='platform', y='count', title='Platform Distribution')
        return fig, {'display': 'block'}

    return {}, {'display': 'none'}  # å¦‚æœæœªé€‰æ‹©æœ‰æ•ˆçš„ angleï¼Œä¸æ˜¾ç¤ºå›¾è¡¨



@app.callback(
    [Output('top-details', 'children'),
     Output('top-details', 'style')],
    [Input('angle-selector', 'value'),
     Input('distribution-bar-chart', 'clickData'),
     Input('upload-data', 'contents'),
     Input('metric-selector', 'value')],
    prevent_initial_call=True
)
def display_top_details_by_selection(angle, clickData, contents, metric):
    ctx = dash.callback_context

    if not ctx.triggered or contents is None:
        # å¦‚æœæ²¡æœ‰è§¦å‘å™¨æˆ–è€…å†…å®¹ä¸ºç©ºï¼Œåˆ™æç¤ºç”¨æˆ·ä¸Šä¼ æ•°æ®
        return 'Upload data to see the top developer.'

    # åˆ¤æ–­æ˜¯å“ªä¸ªè¾“å…¥è§¦å‘äº†å›è°ƒ
    trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # å¤„ç†ä¸Šä¼ çš„æ•°æ®
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # æ ¹æ®è§¦å‘å™¨å’Œangleçš„å€¼ç¡®å®šæ˜¾ç¤ºå“ªä¸ªå¼€å‘è€…
    if trigger_id == 'angle-selector' or trigger_id == 'metric-selector':
        default_label = 'Indie' if angle == 'genre' else 'Windows PC'
        clicked_label = default_label
    elif clickData:
        clicked_label = clickData['points'][0]['x']
    else:
        clicked_label = 'Indie'  # æˆ–è€…æ ¹æ®contextè®¾ç½®ä¸€ä¸ªåˆé€‚çš„é»˜è®¤å€¼

    required_columns = {'name', 'date', 'genre', 'developer', 'platform', 'rating', 'reviews', 'plays', 'description'}
    if not required_columns.issubset(df.columns):
        return [], {'display': 'none'}

    if clicked_label:
        filter_column = 'genre' if angle == 'genre' else 'platform'
        specified = {
            'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
            'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
        }
        specified_values = specified[angle]

        if clicked_label == 'Others':
            filtered_data = df[~df[filter_column].isin(specified_values)]
        else:
            filtered_data = df[df[filter_column] == clicked_label]
        
        # æ£€æŸ¥ filtered_data æ˜¯å¦ä¸ºç©º
        if not filtered_data.empty:
            top_items = filtered_data.nlargest(5, metric)
        else:
            return [], {'display': 'none'}  # å¦‚æœè¿‡æ»¤åæ²¡æœ‰æ•°æ®ï¼Œè¿”å›éšè—æ ·å¼
    else:
        return [], {'display': 'none'}  # å¦‚æœæ²¡æœ‰ clicked_labelï¼Œè¿”å›éšè—æ ·å¼

    children = [html.H4(f"ğŸ¥³   Top 5 Games in '{clicked_label}' by {metric.capitalize()}", style={'marginTop':'10px'})]
    for _, row in top_items.iterrows():
        item_details = html.Div([
            html.H5(row['name']),
            html.P(f"Date: {row.get('date', 'Not available')}"),
            html.P(f"Genre: {row.get('genre', 'Not available')}"),
            html.P(f"Developer: {row.get('developer', 'Not available')}"),
            html.P(f"Platform: {row.get('platform', 'Not available')}"),
            html.P(f"Rating: {row.get('rating', 'Not available')}"),
            html.P(f"Reviews: {row.get('reviews', 'Not available')}"),
            html.P(f"Plays: {row.get('plays', 'Not available')}"),
            html.P(f"Description: {row.get('description', 'No description available.')}")
        ], style={'margin': '10px','marginTop': '20px', 'padding': '10px', 'border-radius': '1rem', 'backgroundColor': 'white'})
        children.append(item_details)

    return children, {'display': 'block'}




@app.callback(
    [Output('distribution-metrics-chart', 'figure'),
     Output('distribution-metrics-chart', 'style')],
    [Input('angle-selector', 'value'),
     Input('metric-selector', 'value'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_metrics_chart(angle, metric, start_date, end_date, contents):
    if contents is None or not metric or metric not in ['plays', 'rating', 'reviews']:
        return {}, {'display': 'none'}  # éšè—å›¾è¡¨

    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))]

    specified_categories = {
        'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
        'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
    }

    filter_column = 'genre' if angle == 'genre' else 'platform'
    specified = specified_categories[filter_column]

    filtered_df[filter_column] = filtered_df[filter_column].str.split(', ')
    exploded_df = filtered_df.explode(filter_column)
    exploded_df[filter_column] = exploded_df[filter_column].apply(lambda x: x if x in specified else 'Others')

    metric_data = exploded_df.groupby(filter_column)[metric].mean().reset_index()
    metric_data.columns = [filter_column, f'average_{metric}']

    # è®¡ç®—æ’åå¹¶æ·»åŠ ä¸€ä¸ªæ–°åˆ—ä»¥æŒ‡ç¤ºå‰ä¸‰å
    metric_data['Top 3'] = metric_data[f'average_{metric}'].rank(ascending=False) <= 3

    # ä½¿ç”¨æ¡ä»¶é¢œè‰²è®¾ç½®çªå‡ºæ˜¾ç¤ºå‰ä¸‰å
    fig = px.bar(metric_data, x=filter_column, y=f'average_{metric}', 
                 title=f'Average {metric.capitalize()} by {angle.capitalize()}',
                 color='Top 3',
                 color_discrete_map={True: 'rgb(255, 215, 0)', False: 'rgb(101, 110, 242)'}  # Gold for top 3, light blue for others
                 )
    fig.for_each_trace(lambda t: t.update(name = 'Top 3' if t.name == 'True' else 'Others'))

    return fig, {'display': 'block'}

    
    



@app.callback(
    Output('unique-developers-output', 'children'),
    [Input('distribution-bar-chart', 'clickData'),
     Input('angle-selector', 'value'),
     Input('upload-data', 'contents')],
    prevent_initial_call=True
)
def display_unique_developers_by_selection(clickData, angle, contents):
    # å¦‚æœæ²¡æœ‰ä¸Šä¼ æ•°æ®ï¼Œåˆ™ä¸æ›´æ–°
    ctx = dash.callback_context

    if not ctx.triggered or contents is None:
        # å¦‚æœæ²¡æœ‰è§¦å‘å™¨æˆ–è€…å†…å®¹ä¸ºç©ºï¼Œåˆ™æç¤ºç”¨æˆ·ä¸Šä¼ æ•°æ®
        return 'Upload data to see the top developer.'

    # åˆ¤æ–­æ˜¯å“ªä¸ªè¾“å…¥è§¦å‘äº†å›è°ƒ
    trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # å¤„ç†ä¸Šä¼ çš„æ•°æ®
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # æ ¹æ®è§¦å‘å™¨å’Œangleçš„å€¼ç¡®å®šæ˜¾ç¤ºå“ªä¸ªå¼€å‘è€…
    if trigger_id == 'angle-selector':
        # å¦‚æœæ˜¯ angle-selector è§¦å‘çš„ï¼Œä½¿ç”¨é»˜è®¤æ ‡ç­¾
        default_label = 'Indie' if angle == 'genre' else 'Windows PC'
        clicked_label = default_label
    else:
        # å¦åˆ™ï¼Œä½¿ç”¨ clickData ä¸­çš„ä¿¡æ¯
        clicked_label = clickData['points'][0]['x'] if clickData else 'Indie'

    # è¿‡æ»¤å¾—åˆ°ç›¸åº”çš„æ•°æ®
    df_filtered = filter_data(df, clicked_label, angle)

    # è®¡ç®—å”¯ä¸€å¼€å‘è€…çš„æ•°é‡
    unique_developers = df_filtered['developer'].nunique()

    # æ„å»ºè¾“å‡ºæ˜¾ç¤ºçš„å†…å®¹
    return html.Div([
        html.H3(f"ğŸ’»   Number of Developers under '{clicked_label}':", style={'fontSize': '16px', 'fontWeight': 'bold', 'color':'white'}),
        html.P(f"{unique_developers}", style={'fontSize': '24px', 'marginTop': '10px', 'fontWeight': 'bold', 'color':'white'})
    ])

def filter_data(df, label, filter_column):
    # æ ¹æ®ç»™å®šçš„åˆ—å’Œæ ‡ç­¾ç­›é€‰æ•°æ®ï¼Œå¤„ç† 'Others' é€‰é¡¹
    specified = {
        'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
        'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
    }
    if label == 'Others':
        df_filtered = df[~df[filter_column].str.contains('|'.join(specified[filter_column]), na=False)]
    else:
        df_filtered = df[df[filter_column].str.contains(label, na=False)]
    
    return df_filtered


@app.callback(
    Output('top-developer-output', 'children'),
    [Input('distribution-bar-chart', 'clickData'),
     Input('angle-selector', 'value'),
     Input('upload-data', 'contents')],
    prevent_initial_call=True
)
def display_top_developer_by_selection(clickData, angle, contents):
    ctx = dash.callback_context

    if not ctx.triggered or contents is None:
        # å¦‚æœæ²¡æœ‰è§¦å‘å™¨æˆ–è€…å†…å®¹ä¸ºç©ºï¼Œåˆ™æç¤ºç”¨æˆ·ä¸Šä¼ æ•°æ®
        return 'Upload data to see the top developer.'

    # åˆ¤æ–­æ˜¯å“ªä¸ªè¾“å…¥è§¦å‘äº†å›è°ƒ
    trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # å¤„ç†ä¸Šä¼ çš„æ•°æ®
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # æ ¹æ®è§¦å‘å™¨å’Œangleçš„å€¼ç¡®å®šæ˜¾ç¤ºå“ªä¸ªå¼€å‘è€…
    if trigger_id == 'angle-selector':
        # å¦‚æœæ˜¯ angle-selector è§¦å‘çš„ï¼Œä½¿ç”¨é»˜è®¤æ ‡ç­¾
        default_label = 'Indie' if angle == 'genre' else 'Windows PC'
        clicked_label = default_label
    else:
        # å¦åˆ™ï¼Œä½¿ç”¨ clickData ä¸­çš„ä¿¡æ¯
        clicked_label = clickData['points'][0]['x'] if clickData else 'Indie'

    # æ ¹æ® angle è®¾ç½®é»˜è®¤ç‚¹å‡»æ ‡ç­¾
    specified_categories = {
        'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
        'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
    }
    filter_column = 'genre' if angle == 'genre' else 'platform'
    specified = specified_categories[filter_column]

    if clicked_label == 'Others':
        df_filtered = df[~df[filter_column].str.contains('|'.join(specified), na=False)]
    else:
        df_filtered = df[df[filter_column].str.contains(clicked_label, na=False)]

    developer_counts = df_filtered['developer'].value_counts().reset_index()
    developer_counts.columns = ['developer', 'count']

    if not developer_counts.empty:
        top_developer = developer_counts.iloc[0]['developer']
        top_developer_games_count = developer_counts.iloc[0]['count']
        return html.Div([
            html.H4(f"ğŸ†     Top Developers under '{clicked_label}' {angle}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
            html.P(f"{top_developer} ({top_developer_games_count} games)", style={'fontSize': '20px', 'marginTop': '10px', 'fontWeight': 'bold'})
        ])
    else:
        return f"No games found in the '{clicked_label}' {angle}."






    
# ç¡®ä¿ä½ çš„å¸ƒå±€ä¸­æœ‰ä»¥ä¸‹å…ƒç´ ï¼š
# dcc.Graph(id='distribution-bar-chart'),
# html.Div(id='top-developer-metric-output'),
# dcc.Dropdown(id='angle-selector'),
# dcc.Dropdown(id='metric-selector'),

@app.callback(
    Output('top-developer-metric-output', 'children'),
    [Input('distribution-bar-chart', 'clickData'),
     Input('angle-selector', 'value'),
     Input('metric-selector', 'value'),
     Input('upload-data', 'contents')],
    prevent_initial_call=True
)
def display_top_developers_metric(clickData, angle, metric, contents):
    ctx = dash.callback_context

    if not ctx.triggered or contents is None:
        # å¦‚æœæ²¡æœ‰è§¦å‘å™¨æˆ–è€…å†…å®¹ä¸ºç©ºï¼Œåˆ™æç¤ºç”¨æˆ·ä¸Šä¼ æ•°æ®
        return 'Upload data to see the top developer.'

    # åˆ¤æ–­æ˜¯å“ªä¸ªè¾“å…¥è§¦å‘äº†å›è°ƒ
    trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # å¤„ç†ä¸Šä¼ çš„æ•°æ®
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # æ ¹æ®è§¦å‘å™¨å’Œangleçš„å€¼ç¡®å®šæ˜¾ç¤ºå“ªä¸ªå¼€å‘è€…
    if trigger_id == 'angle-selector' or trigger_id == 'metric-selector':
        default_label = 'Indie' if angle == 'genre' else 'Windows PC'
        clicked_label = default_label
    elif clickData:
        clicked_label = clickData['points'][0]['x']
    else:
        clicked_label = 'Indie'  # æˆ–è€…æ ¹æ®contextè®¾ç½®ä¸€ä¸ªåˆé€‚çš„é»˜è®¤å€¼

    # æ ¹æ®é€‰æ‹©çš„è§’åº¦è®¾ç½®é»˜è®¤æ ‡ç­¾
    specified_categories = {
        'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
        'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
    }

    # æ ¹æ®è§’åº¦é€‰æ‹©å™¨çš„å€¼ç­›é€‰æ•°æ®
    filter_column = 'genre' if angle == 'genre' else 'platform'
    specified = specified_categories[filter_column]

    if clicked_label == 'Others':
        df_filtered = df[~df[filter_column].str.contains('|'.join(specified), na=False)]
    else:
        df_filtered = df[df[filter_column].str.contains(clicked_label, na=False)]

    # è®¡ç®—æ¯ä¸ªå¼€å‘è€…çš„å¹³å‡metricå€¼
    if metric in ['plays', 'rating', 'reviews']:
        developer_metric_avg = df_filtered.groupby('developer')[metric].mean().reset_index()
        developer_metric_avg.columns = ['developer', f'average_{metric}']
        developer_metric_avg.sort_values(by=f'average_{metric}', ascending=False, inplace=True)


        # åˆ›å»ºæ»šåŠ¨å®¹å™¨å¹¶æ·»åŠ æ¯ä¸ªå¼€å‘è€…çš„è¯¦ç»†ä¿¡æ¯
        children = html.Div(
            [
                html.Div(
                    [
                        html.H4(
                            f"ğŸ‰   Top Developers in '{clicked_label}' by Average {metric.capitalize()}:",
                            style={
                                'fontSize': '16px',  # Larger font size for heading
                                'fontWeight': 'bold',
                                'color': '#5e72e4',  # Matching the primary color theme
                                'marginTop':'15px',
                                'marginBottom': '15px',  # Spacing between the header and list
                                'padding': '10px',  # Padding around the text for better spacing
                                'backgroundColor': '#f8f9fa',  # Light background for the header
                                'borderRadius': '5px',  # Rounded corners for the header
                                'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)'  # Subtle shadow for depth
                            }
                        ),
                        html.Ul(
                            [
                                html.Li(
                                    f"{row['developer']}: {row[f'average_{metric}']:.2f}", 
                                    style={
                                        'fontSize': '16px',  # Uniform font size for list items
                                        'color': '#343a40',  # Darker text for readability
                                        'padding': '5px',  # Padding for list items
                                        'borderBottom': '1px solid #e9ecef',  # Divider between items
                                        'last-child': {'border': 'none'}  # Remove border for the last item
                                    }
                                ) for _, row in developer_metric_avg.head(5).iterrows()
                            ],
                            style={
                                'listStyleType': 'none',  # Remove bullets from the list
                                'margin': '0',  # Remove default margin
                                'maxHeight': '250px',  # Limit the height of the list
                                'overflowY': 'auto',  # Allow scrolling within the list
                                'backgroundColor': '#ffffff',  # White background for the list
                                'borderRadius': '5px',  # Rounded corners for the list
                                'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)',  # Subtle shadow for depth
                            }
                        )
                    ],
                    style={
                        'padding': '10px',  # Padding around the entire component
                        'backgroundColor': 'rgba(94, 114, 228, 0.5)',  # Semi-transparent primary color background
                        'borderRadius': '5px',  # Rounded corners for the outer div
                        'boxShadow': '0 4px 8px rgba(0, 0, 0, 0.2)',  # Shadow for the outer div
                        'height': '303px', 
                        "justify-content": "center", "align-items": "center"
                    }
                )

            ],
            style={'display': 'block'}
        )
    else:
        children = f"No valid metric selected."

    return children




import numpy as np
import pandas as pd
import plotly.express as px
from dash import Dash, html, dcc, Input, Output, callback  # æ ¹æ®æ‚¨çš„Dashç‰ˆæœ¬ï¼Œå¯¼å…¥æ–¹å¼å¯èƒ½ç•¥æœ‰ä¸åŒ

# å‡è®¾ä»¥ä¸‹æ˜¯æ‚¨Dashåº”ç”¨çš„ä¸€éƒ¨åˆ†







if __name__ == '__main__':
    app.run_server(debug=True)
