import dash
from dash import dcc, callback, html, State, callback_context
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import pandas as pd
import io
import base64
from datetime import datetime
import tabulate
import plotly.express as px
import plotly.graph_objs as go



#新增：cluster analysis所需要的安装包
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.cluster import KMeans
from dash.exceptions import PreventUpdate
from dash import dash_table
from dash.dash_table.Format import Format 
import plotly.graph_objs as go
from dash import no_update

card_content_a = [
    dbc.CardHeader(
        [
            html.Div([
                html.H1(id="num-games"),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
    dbc.CardFooter(
        [
            html.Div([html.I(className="bi bi-controller"), "Number of Games"], className="text-center"),
        ]
    ),
]

card_content_b = [
    dbc.CardBody(
        [
            html.H1(id="num-genres", className="text-center"),
        ],
    ),
    dbc.CardFooter(
        [
            html.Div([html.I(className="bi bi-tags-fill"), "Number of Genres"], className="text-center"),
        ]
    ),
]

card_content_c = [
    dbc.CardHeader(
        [
            html.Div([
                html.H1(id="unique-developers"),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
    dbc.CardFooter(
        [
            html.Div([html.I(className="bi bi-code-square"), "Number of Developers"], className="text-center"),
        ]
    ),
]

card_content_d = [
    dbc.CardHeader(
        [
            html.Div([html.I(className="bi bi-collection-play-fill"), "Average Plays"], className="text-center"),
        ]
    ),
    dbc.CardBody(
        [
            html.Div([
                html.H1(id="avg-plays"),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
]
card_content_e = [
    dbc.CardBody(
        [
            html.Div([
                html.H1(id="avg-rating", style={'color': 'white'}),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
    dbc.CardFooter(
        [
            html.Div([html.I(className="bi bi-star"), "Average Rating"], className="text-center"),
        ]
    ),
]
card_content_f = [
    dbc.CardHeader(
        [
            html.Div([html.I(className="bi bi-chat-left-text-fill"), "Number of Descriptions"], className="text-center"),
        ]
    ),
    dbc.CardBody(
        [
            html.Div([
                html.H1(id="num-description"),
            ], className="text-center",
                style={"display": "flex", "justify-content": "center", "align-items": "center"}),
        ],
    ),
]

# Define the cards of Feedback 
# Define the card style with rounded corners and shadows
card_style_a = {
    'backgroundColor': 'rgba(94, 114, 228, 0.75)',  # Semi-transparent blue background
    'boxShadow': '0 4px 8px rgba(0, 0, 0, 0.15)',  # Subtle shadow
    'borderRadius': '0.5rem',  # Rounded corners
    'marginBottom': '20px',  # Space between cards
    'overflow': 'hidden',  # Prevents content from spilling out
    'display': 'flex',  # Enables flexbox
    'flexDirection': 'column',  # Stack children vertically
    'justifyContent': 'center',  # Center vertically
    'alignItems': 'center'  # Center horizontally
}

card_style_b = {
    'backgroundColor': 'rgba(94, 114, 228, 0.25)',  # Semi-transparent blue background
    'boxShadow': '0 4px 8px rgba(0, 0, 0, 0.15)',  # Subtle shadow
    'borderRadius': '0.5rem',  # Rounded corners
    'marginBottom': '20px',  # Space between cards
    'overflow': 'hidden',  # Prevents content from spilling out
    'display': 'flex',  # Enables flexbox
    'flexDirection': 'column',  # Stack children vertically
    'justifyContent': 'center',  # Center vertically
    'alignItems': 'center'  # Center horizontally
}


# First card with consistent style
card_a = dbc.Card([
    dbc.CardBody([
        html.H1(id="unique-developers-output", className="text-center", style={'marginTop':'10px'})
    ])
], style=card_style_a)

# Second card with consistent style
card_b = dbc.Card([
    dbc.CardBody([
        html.H1(id="top-developer-output", className="text-center", style={'marginTop':'10px'})
    ])
], style=card_style_b)


#-------------------------------------------------------------------------------------------------------


filter_bar = html.Div([
        dbc.Select(
            id='time-series-selection',
            options=[
                {'label': 'Number of Games Released', 'value': 'Number_of_games'},
                {'label': 'Total Plays', 'value': 'Total_plays'},
                {'label': 'Average Rating', 'value': 'Average_rating'},
                {'label': 'Rank of Genre', 'value': 'Rank_of_Genre'}
            ],
            value='Number_of_games',  # Set the default value
            className='my-2',  # Maintain the margin
            html_size="lg",  # Make the select larger to match other inputs
        )
],className="mb-4")



genre_checklist = html.Div([
    dbc.Label("Select Genres: (After selecting, result show below ⬇️)"),
    dcc.Checklist(
        id='genre-checklist',
        options=[],  # Initially empty
        value=[],    # Initially empty
        inline=True
    )
], className="mb-3")  # You can adjust className for styling as per your needs


enter_year = html.Div(
            [
                html.P("Enter Year:"),
                dcc.Input(
                    id='year-input',
                    type='number',
                    value=2000,
                    min=1900,
                    max=datetime.now().year,
                    step=1
                )
            ],
            id='input-container',
            style={'display': 'None'},  # Initially invisible 
    className="mb-4")  # Add a bottom margin

#---------------------------------------------------------------------------------------------------------




filter_bar_angle = dbc.CardGroup(
    [
        dbc.Label("Select Angle:", html_for="dropdown"),
        dbc.Select(
            id='angle-selector',
            options=[
                {'label': 'Genre', 'value': 'genre'},
                {'label': 'Platform', 'value': 'platform'}
            ],
            value='genre',  # Default selection
            className='mb-3',  # Margin bottom for spacing
        ),
    ]
)

filter_bar_metric = dbc.CardGroup(
    [
        dbc.Label("Select Metric:", html_for="dropdown"),
        dbc.Select(
            id='metric-selector',
            options=[
                {'label': 'Rating', 'value': 'rating'},
                {'label': 'Plays', 'value': 'plays'},
                {'label': 'Reviews', 'value': 'reviews'}
            ],
            value='rating',  # Default selection
            className='mb-3',  # Margin bottom for spacing
        ),
    ]
)

layout_section = dbc.Row(
    [
        dbc.Col(filter_bar_angle, width=6),
        dbc.Col(filter_bar_metric, width=6)
    ],
    className='my-3'  # Margin top and bottom for the entire row
)

feedback_tab_content = [
    layout_section,  # Your existing filter bar or other setup content

    # Single row for the graphs and the details
    dbc.Row([
        # Column for the first graph and its related information
        dbc.Col([
            dcc.Graph(
                id='distribution-bar-chart', 
                style={
                    'minWidth': '100%',
                    'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)',  # Adding light shadow for card effect
                    'padding': '20px',  # Optional: adds space inside the div container for aesthetic purposes
                    'background': 'white'  # Ensuring the background is white for consistency
                }
            ),
            html.Hr(),  # Horizontal line for visual separation
            dbc.Col(card_a), 
            dbc.Col(card_b)
        ], width=4, className='pe-2'),  # This takes up a third of the row, adding padding on the right for separation

        # Column for the second graph
        dbc.Col([
            dcc.Graph(
                id='distribution-metrics-chart',
                style={
                    'minWidth': '100%',
                    'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)',  # Adding light shadow for card effect
                    'padding': '10px',  # Optional: adds space inside the div container for aesthetic purposes
                    'background': 'white'  # Ensuring the background is white for consistency
                }
            ),
            html.Hr(),  # Horizontal line for visual separation
            # Use a Card to enclose the metrics output
            dbc.Col(id='top-developer-metric-output')
        ], width=4, className='pe-2'),  # This takes up a third of the row, add

        # Column for detailed textual information
        dbc.Col(html.Div([
            html.Div([
                # Merged content
                html.Div(id='top-details', style={'padding': '5px'}),
            ], style={
                'overflow-y': 'auto',  # Enable vertical scrolling within this div
                'height': '765px'  # Set to match graph height
            })
        ], style={
            'height': '785px',  # Same height as the graph
            'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)',  # Adding shadow
            'borderRadius': '1rem',  # Rounded corners
            'padding': '10px',
            'backgroundColor': 'rgba(94, 114, 228, 0.25)'  # Primary color with 50% transparency
        }), width=4, className='g-0')  # Adjust width to match combined width of the left columns
    ], className='g-0 mx-0')  # Use 'g-0' to remove gutters completely, 'mx-0' to remove horizontal margins
]




app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP, dbc.icons.BOOTSTRAP])

app.layout = dbc.Container(children=[
    # 包裹在蓝色背景中的部分
    html.Div([
        html.H1('Games Dashboard', className='text-white', style={'textAlign': 'center'}),
        
        # 新增：Upload提示和Upload按钮的容器
        html.Div(
            style={'display': 'flex', 'alignItems': 'center', 'justifyContent': 'space-between', 'backgroundColor': '#5e72e4', 'color': 'white'},
            children=[
        # 左侧：Upload提示和Upload按钮的容器
                html.Div(
                    style={'display': 'flex', 'alignItems': 'center'},
                    children=[
                        # Upload button
                        dcc.Upload(
                            id='upload-data',
                            children=dbc.Button('Choose File', color="primary", className='me-2 shadow-sm', style={'fontWeight': 'bold', 'marginTop': '10px'}),
                            multiple=False  # Restrict to single file upload
                        ),
                        # Upload提示文字
                        html.Div(id='data-summary-text', style={'fontWeight': 'bold', 'marginLeft': '15px', 'marginTop': '-5px'})
                    ]
                ),

                html.Div(
                    style={'display': 'flex', 'alignItems': 'center'},
                    children=[

                        # 中间：文本提示选择时间段
                        html.Div(
                            style={'fontWeight': 'bold', 'marginRight': '15px', 'marginTop': '-5px'},
                            children="Select the time period you want to analyse: "
                        ),
                        
                        # 右侧：日期选择器
                        dcc.DatePickerRange(
                            id='date-picker-range',
                            display_format='YYYY-MM-DD',
                            start_date='1900-01-01',  # 设置默认开始日期为 1900-01-01
                            end_date=datetime.today().strftime('%Y-%m-%d'),  # 设置默认结束日期为今天的日期
                            style={'borderRadius': '5px', 'border': 'none'}
                        )
                    ]
                )
    ]
),

    ], style={'backgroundColor': '#5e72e4', 'padding': '20px'}),

    
    
    #------------------------------------------------------------------------------------------------
    
    # 在 app.layout 内部添加
    dcc.Store(id='genre-list-store'),
    
    

    #-------------------------------------------------------------------------------------------------
    

    # 主要内容区域，背景为白色
    html.Div([
        dcc.Tabs(id="tabs", children=[
            dcc.Tab(label='Overview', children=[  
                html.Div([  # Container for cards with padding
                    dbc.Row(
                        [
                            dbc.Col(dbc.Card(card_content_a, color="primary", inverse=True)),
                            dbc.Col(dbc.Card(card_content_b, color="primary", outline=True)),
                            dbc.Col(dbc.Card(card_content_c, color="primary", inverse=True)),
                        ],
                        className="mb-4",  # Margin bottom for spacing between rows
                    ),
                    dbc.Row(
                        [
                            dbc.Col(dbc.Card(card_content_d, color="primary", outline=True)),
                            dbc.Col(dbc.Card(card_content_e, color="primary", inverse=True)),
                            dbc.Col(dbc.Card(card_content_f, color="primary", outline=True)),
                        ],
                        className="mb-4",  # Increase margin bottom if needed
                    ),
                ], style={'paddingTop': '30px'}),

                dbc.Row(
                    style={'marginTop': '30px', 'textAlign': 'center'},
                    children=[html.H2("Time Series Analysis")],
                ),

                # 新增：filter bar
                filter_bar,
                
                #-----------------------------------------------------------------------------------------
                genre_checklist,
                
                enter_year,

                #-----------------------------------------------------------------------------------------


                
                # 用于显示时间序列图表的container
                dbc.Row(id='time-series-chart', style={'width': '100%', 'marginTop': '20px'}),


            ]),

            dcc.Tab(label='Relationship', children=[
                dbc.Row([
                    dbc.Col(html.Div(id='reviews-rating-chart', style={'marginTop': '10px'}), width=6),
                    dbc.Col(html.Div(id='plays-playing-chart', style={'marginTop': '10px'}), width=6),
                ]),
                dbc.Row([
                    dbc.Col(dcc.Graph(id='rating-comparison-chart'), width=12),
                ])
            ]),

            dcc.Tab(label='Feedback', children=feedback_tab_content),

            dcc.Tab(label='Recommendation', children=[
                # Search bar
                html.Div(
                    style={'display': 'flex', 'justifyContent': 'flex-start', 'marginRight': '10px', 'marginTop': '20px', 'flexGrow': '1'},
                    children=[
                        dbc.Input(id='search-bar', type='text', placeholder='Search for a game...', className='me-1', style={'width': '1250px', 'height': '50px'}),
                        html.Div(  # 内部容器，用于更灵活地控制搜索按钮的位置
                            style={'marginLeft': '20px', 'alignSelf': 'flex-start'},  # 控制内部按钮的左边距和垂直对齐
                            children=[
                                dbc.Button('Search', id='search-button', n_clicks=0, color="primary", className='me-2 shadow-sm', style={'fontWeight': 'bold', 'marginTop': '3px'}),
                            ])]
                ),
                html.Div(id='game-details-output', style={'marginTop': '20px'})
            ]),
        ]),
    ], style={'backgroundColor': 'white'}),  # 设置整个内容区域背景色为白色
])

@app.callback(
    Output('date-picker-range', 'start_date'),
    [Input('upload-data', 'contents')]
)
def update_date_range(contents):
    if contents is None:
        # Return the default start date if no file is uploaded
        return '1900-01-01'
    
    # Decode the uploaded file content
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
    
    # Convert 'date' column to datetime
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    
    # Get the minimum date from the 'date' column
    min_date = df['date'].min()
    
    # Check if min_date is NaT (not a time), then return default, otherwise return min_date
    return min_date if pd.notna(min_date) else '1900-01-01'


# Callback to update the graph based on the uploaded file
@app.callback(
    [Output('data-summary-text', 'children'),
     Output('num-games', 'children'),
     Output('num-genres', 'children'),
     Output('unique-developers', 'children'),
     Output('avg-plays', 'children'),
     Output('avg-rating', 'children'),
     Output('num-description', 'children')],
    
    [Input('upload-data', 'contents'),
     Input('upload-data', 'filename'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date')] 
    
)

def update_summary(content, filename, start_date, end_date):

    # Initial placeholders for the statistics
    num_games = num_genres = unique_developers = avg_plays = avg_rating = num_description = 'N/A'
    
    
    if content is None:
        return 'Upload a file to start the analysis.', num_games, num_genres, unique_developers, avg_plays, avg_rating, num_description

    # Decode the uploaded file
    content_type, content_string = content.split(',')
    decoded = io.StringIO(base64.b64decode(content_string).decode('utf-8'))
    df = pd.read_csv(decoded)
    # Give a summary of the file
    summary_text = f'The file {filename} has been uploaded.'

    # Filter according to date selection
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    filtered_df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))]
    # Overview of data within the selected date range
    num_games = len(filtered_df)
    num_genres = filtered_df['genre'].nunique()
    unique_developers = filtered_df['developer'].nunique()
    avg_plays = round(filtered_df['plays'].mean(), 2)
    avg_rating = round(filtered_df['rating'].mean(), 2)
    num_description = filtered_df['description'].notna().sum()

    
    return summary_text, num_games, num_genres, unique_developers, avg_plays, avg_rating, num_description


# ----------以下为更新-------------------------------------------------------------------------------------------


@app.callback(
    Output('genre-list-store', 'data'),
    [Input('upload-data', 'contents')]
)
def update_genre_list(contents):
    if contents is None:
        raise PreventUpdate

    # 解析上传的文件内容
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # 'genre' 列中的每个条目包含多个用逗号分隔的类型
    genres = set()
    for genre_list in df['genre'].dropna().unique():
        genres.update([genre.strip() for genre in genre_list.split(',')])
    
    # 返回所有唯一的游戏类型
    return list(genres)


@app.callback(
    Output('genre-checklist', 'options'),
    [Input('genre-list-store', 'data')]
)
def set_checklist_options(genres):
    if not genres:
        return []
    # 确保选项按字母顺序排序，以便用户容易查找
    return [{'label': genre, 'value': genre} for genre in sorted(genres)]


@app.callback(
    [
    Output('time-series-chart', 'children'),
    Output('input-container', 'style'),  # Control visibility of the input container
    
    ],
    [Input('upload-data', 'contents'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('time-series-selection', 'value'),
     Input('genre-checklist', 'value'), # 接收checklist的输入
     Input('year-input', 'value')  # Include the year from the input box
    
] 
)


def update_time_series_chart(contents, start_date, end_date, time_series_selection, genres, year):
    if contents is None:
        raise PreventUpdate

     
    
    # Handling time series selections
    if time_series_selection != 'Rank_of_Genre':
        graphs = []
    
        # Parse uploaded file
        content_type, content_string = contents.split(',')
        decoded = base64.b64decode(content_string)
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

        # Filter according to date selection
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        filtered_df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))]

        # Check if filtered_df is empty
        if filtered_df.empty:
            return [html.Div("No data available for the selected date range.")], {'display': 'none'}

        
        
        # Calculate the length of the date range
        start_year = pd.to_datetime(start_date).year
        end_year = pd.to_datetime(end_date).year

        resample_code = 'Y' if start_year != end_year else 'M'
        title_suffix = 'Year' if start_year != end_year else 'Month'
        title = lambda field: f'{field} per {title_suffix} Over Time (All Games)'
        title2 = lambda field: f'{field} per {title_suffix} Over Time (Specific Genres)'
        
        

        field = 'plays' if time_series_selection == 'Total_plays' else 'rating' if time_series_selection == 'Average_rating' else None
        operation = 'sum' if time_series_selection == 'Total_plays' else 'mean' if time_series_selection == 'Average_rating' else 'size'
        aggregated_data = filtered_df.resample(resample_code, on='date')[field].agg(operation) if field else filtered_df.resample(resample_code, on='date').size()
        
        if not aggregated_data.empty:
            aggregated_data.index = aggregated_data.index.to_period(resample_code).start_time
            fig = go.Figure()
            fig.add_trace(go.Scatter(x=aggregated_data.index, y=aggregated_data, mode='lines+markers', name='All Games'))
            fig.update_layout(
                title=title(time_series_selection.replace('_', ' ').title()),
                xaxis_title='Date',
                yaxis_title=time_series_selection.replace('_', ' ').title()
            )

            # Adjusting x-axis tick format
            tickformat = "%Y" if resample_code == 'Y' else "%Y-%m"
            fig.update_xaxes(dtick="M12" if resample_code == 'Y' else "M1", tickformat=tickformat)
            fig.update_xaxes(tickfont=dict(size=8))
            
            graphs.append(dcc.Graph(figure=fig))    

        if genres:
            
            fig2 = go.Figure()
            data_available = False

            for genre in genres:
                genre_df = filtered_df[filtered_df['genre'].str.contains(genre, case=False, na=False)]

                if not genre_df.empty:
                    
                    genre_specific_data = genre_df.resample(resample_code, on='date')[field].agg(operation) if field else genre_df.resample(resample_code, on='date').size()
                    
                    if not genre_specific_data.empty:
                        
                        genre_specific_data.index = genre_specific_data.index.to_period(resample_code).start_time

                        fig2.add_trace(go.Scatter(x=genre_specific_data.index, y=genre_specific_data, mode='lines+markers', name=f'Games in {genre}'))
                        data_available = True  # 至少有一个genre有数据

                        
            if not fig2.data:
                graphs.append(html.Div("No sufficient data available for any selected genres."))
            else:
                fig2.update_layout(title=title2(time_series_selection.replace('_', ' ').title()), xaxis_title='Date', yaxis_title=time_series_selection.replace('_', ' '), showlegend=True)
                fig2.update_layout(legend=dict(font=dict(size=8)))
                # Adjusting x-axis tick format
                tickformat = "%Y" if resample_code == 'Y' else "%Y-%m"
                fig2.update_xaxes(dtick="M12" if resample_code == 'Y' else "M1", tickformat=tickformat)
                fig2.update_xaxes(tickfont=dict(size=8))                
                
                graphs.append(dcc.Graph(figure=fig2))

        #return graphs 
            pass


                         
                               
    if time_series_selection == 'Rank_of_Genre':
        # Specifically handling the "Rank of Genre" selection
        content_type, content_string = contents.split(',')
        decoded = base64.b64decode(content_string)
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        # Filter according to date selection
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date)) & (df['date'].dt.year == year)]  # Filter data for the selected year

        # Calculate the length of the date range
        start_year = pd.to_datetime(start_date).year
        end_year = pd.to_datetime(end_date).year
        
        
        # Explode genre column to handle multiple genres per game
        df['genre'] = df['genre'].str.split(', ')
        df = df.explode('genre')

        # Count unique genres for the title
        unique_genres = df['genre'].nunique()

        # Group by genre and calculate metrics
        df['genre'] = df['genre'].fillna('Unknown')  # Replace NaN with a placeholder if appropriate

        games_count = df['genre'].value_counts().reset_index(name='Game Count')
        total_plays = df.groupby('genre')['plays'].sum().reset_index(name='Total Plays')
        average_rating = df.groupby('genre')['rating'].mean().reset_index(name='Average Rating')


        # Ensure an outer join to keep all genres
        summary_df = games_count.merge(total_plays, on='genre', how='outer')\
                                .merge(average_rating, on='genre', how='outer')

        # Handle missing values after the merge
        summary_df.fillna({'Game Count': 0, 'Total Plays': 0, 'Average Rating': 'No Rating'}, inplace=True)

        # Calculate rankings with handling of missing values
        summary_df = summary_df[summary_df['genre'] != 'Unknown']

        summary_df['Game Count Rank'] = summary_df['Game Count'].rank(method='min', ascending=False)
        summary_df['Total Plays Rank'] = summary_df['Total Plays'].rank(method='min', ascending=False)
        summary_df['Average Rating Rank'] = summary_df['Average Rating'].replace('No Rating', np.nan).rank(method='min', ascending=True)
        
        # After calculating rankings, sort by 'Average Rating Rank'
        # Note: We'll use ascending order since a lower rank number means a better rank
        summary_df.sort_values(by='Average Rating Rank', ascending=True, inplace=True)



        # Highlight selected genres
        summary_df['Selected'] = summary_df['genre'].apply(lambda x: 'gold' if x in genres else 'white')
        
        if year < start_year or year > end_year:
            graphs=html.Div(f'{year} is out of your selected date range.')
            
        else:

            # Creating the table with Plotly
            fig = go.Figure(data=[go.Table(
                header=dict(values=['Genre', 'Average Rating Rank', 'Game Count Rank', 'Total Plays Rank']),
                cells=dict(values=[summary_df['genre'], summary_df['Average Rating Rank'], summary_df['Game Count Rank'], summary_df['Total Plays Rank']],
                           fill_color=[summary_df['Selected'], 'white', 'white', 'white'])
            )])
            fig.update_layout(title_text=f"Rank of Genres for the Year {year} (Number of Total Unique Genres: {unique_genres})")


            graphs = [dcc.Graph(figure=fig)]
            
        return graphs, {'display': 'block'}






    return graphs, {'display': 'none'}  # Default return when "Rank of Genre" is not selected

# -----------------------------------------------------------------------------------------------------------------




# Callback to update the searched game data
@app.callback(
    Output('game-details-output', 'children'),
    [Input('search-button', 'n_clicks'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date')],
    [State('search-bar', 'value'),
     State('upload-data', 'contents')]
)

def search_game(n_clicks_search, start_date, end_date, search_value, content):
    ctx = callback_context

    # Determine which button was clicked
    if not ctx.triggered:
        button_id = 'No buttons clicked yet'
    else:
        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
    
    # If the search button was clicked and there's valid input and file content
    if button_id == 'search-button' and n_clicks_search and search_value and content:
        content_type, content_string = content.split(',')
        decoded = base64.b64decode(content_string)
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        df['date'] = pd.to_datetime(df['date'])

        # Normalize case for a case-insensitive full match
        search_value_lower = search_value.lower()
        df['name_lower'] = df['name'].str.lower()

        # Check for a full match rather than a partial match
        match_df = df[df['name_lower'] == search_value_lower]
            
        
        if not match_df.empty:
            # Assuming the first match is the desired one
            game_info = match_df.iloc[0][['name', 'date', 'genre', 'developer', 'platform', 'rating', 'wishlists', 'description']].to_dict()
            #return [html.P(f"{game_info['name']} found")]
            game_details = [
                html.H4(game_info.get('name', 'No Name')),
                html.P(f"Date: {game_info['date'].strftime('%Y-%m-%d') if pd.notna(game_info['date']) else 'No information available'}"),
                html.P(f"Genre: {game_info['genre'] if pd.notna(game_info['genre']) else 'No information available'}"),
                html.P(f"Developer: {game_info['developer'] if pd.notna(game_info['developer']) else 'No information available'}"),
                html.P(f"Platform: {game_info['platform'] if pd.notna(game_info['platform']) else 'No information available'}"),
                html.P(f"Rating: {game_info['rating'] if pd.notna(game_info['rating']) else 'No information available'}"),
                html.P(f"Wishlists: {game_info['wishlists'] if pd.notna(game_info['wishlists']) else 'No information available'}"),
                html.P(f"Description: {game_info['description'] if pd.notna(game_info['description']) else 'No information available'}"),
            ]

            # Exclude the searched game itself from similar game search
            curr_game = game_info['name']
            
            # Filter for games with genre and rating
            no_genre = pd.isna(game_info['genre'])
            no_rating = pd.isna(game_info['rating'])

            if no_genre:
                return game_details + [html.P("Not enough information to find similar games.")]
            
            genre_filter = df['genre'].str.contains(game_info['genre'], case=False, na=False)
            date_filter = (df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))
            relevant_games_df = df[genre_filter & date_filter & (df['name'] != curr_game)]

            game_count = relevant_games_df.shape[0]
            if game_count == 0:
                top_games_details = [html.P("There are no similar games within the selected time frame.")]
                return game_details + top_games_details
            else:
                top_games_df = relevant_games_df.sort_values(by='rating', ascending=False).head(min(5, game_count))
                header_text = f"Top {min(game_count, 5)} games in the same genre and time frame:"
                top_games_details = [html.H5(header_text)]
                top_games_details.extend([
                html.P([
                    game['name'],
                    html.Br(),  # This inserts an actual HTML line break element
                    f"Rating: {game['rating']}"]) for _, game in top_games_df.iterrows()
                ])
                
            if no_rating:
                return game_details + top_games_details
            else:
                # The date and rating of the specific game
                game_rating = game_info['rating']
                game_date = pd.to_datetime(game_info['date'])
                # Take away games with no ratings
                rating_rank_df = relevant_games_df.dropna(subset=['rating'])
                rating_rank_df = pd.concat([rating_rank_df, match_df], ignore_index=True)          
                # Calculate ranks and percentile ranks
                rating_rank_df['rating_rank'] = rating_rank_df['rating'].rank(method='max')  # Use 'max' to handle ties
                rating_rank_df['percentile_rank'] = rating_rank_df['rating_rank'] / len(rating_rank_df) * 100
                # Find the percentile rank for the specific game
                game_percentile = rating_rank_df[rating_rank_df['rating'] == game_rating]['percentile_rank'].max()
                percentile_message = [html.P(f"The rating of {game_info['name']} exceeds {game_percentile:.2f} percent of games for similar games within the selected time frame.")]
                return game_details + top_games_details + percentile_message
            
            
        else:
            # No exact match found
            # Filter for games starting with the search value
            match_df = df[df['name_lower'].str.startswith(search_value_lower)]
            if match_df.shape[0] > 0:
                # Limit to the first 10 games and create a list with each game on a new line
                games_list = match_df['name'].head(10).tolist()
                suggestions = [html.P(f"Are you looking for one of these games?")] + \
                              [html.Div(game) for game in games_list]
                return suggestions
            else:
                no_match_message = html.P("Game information not available.")
                return [no_match_message]
    return []

    
       
    
#新增relationship
@app.callback(
    Output('reviews-rating-chart', 'children'),
    [Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_reviews_rating_chart(start_date, end_date, contents):
    if contents is None:
        raise PreventUpdate
    
    # 解析上传的文件
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
    
    # 过滤数据集以符合选择的日期范围
    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= start_date) & (df['date'] <= end_date)]
    
    # 生成散点图
    fig = px.scatter(filtered_df, x='reviews', y='rating', 
                     title='Relationship between Number of Reviews and Rating',
                     hover_data=['name'])  # 悬停时显示游戏名称
    
    # 转换图表为HTML元素
    graph_html = dcc.Graph(figure=fig)
    
    return graph_html




@app.callback(
    Output('plays-playing-chart', 'children'),
    [Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_plays_playing_chart(start_date, end_date, contents):
    if contents is None:
        raise PreventUpdate
    
    # 解析上传的文件
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
    
    # 过滤数据集以符合选择的日期范围
    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= start_date) & (df['date'] <= end_date)].copy()
    
    # 生成散点图
    fig = px.scatter(filtered_df, x='plays', y='playing', 
                     title='Relationship between Plays and Playing',
                     hover_data=['name'])  # 悬停时显示游戏名称
    
    # 转换图表为HTML元素
    graph_html = dcc.Graph(figure=fig)
    
    return graph_html


@app.callback(
    Output('rating-comparison-chart', 'figure'),
    [Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_rating_comparison_chart(start_date, end_date, contents):
    if contents is None:
        raise PreventUpdate

    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= start_date) & (df['date'] <= end_date)].copy()

    # Identify the developer category based on inclusion of Sony, Microsoft, or Nintendo
    conditions = [
        filtered_df['developer'].str.contains('Sony', case=False, na=False),
        filtered_df['developer'].str.contains('Microsoft', case=False, na=False),
        filtered_df['developer'].str.contains('Nintendo', case=False, na=False)
    ]
    choices = ['Sony', 'Microsoft', 'Nintendo']
    filtered_df['Developer Category'] = np.select(conditions, choices, default='Others').copy()

    # Plotting the box plot
    fig = px.box(filtered_df, x='Developer Category', y='rating', title='Rating Distribution by Developer Category')

    return fig



@app.callback(
    [Output('distribution-bar-chart', 'figure'),  # 图表数据
     Output('distribution-bar-chart', 'style')],  # 控制显示样式
    [Input('angle-selector', 'value'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_distribution_bar_chart(angle, start_date, end_date, contents):
    if contents is None:
        return {}, {'display': 'none'}

    # 解析上传的文件
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # 过滤数据集以符合选择的日期范围
    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))]

    if angle == 'genre':
        # 分类处理和柱状图制作 - Genre
        filtered_df['genre'] = filtered_df['genre'].str.split(', ')
        exploded_df = filtered_df.explode('genre')
        specified_genres = ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade']
        exploded_df['genre'] = exploded_df['genre'].apply(lambda x: x if x in specified_genres else 'Others')
        genre_counts = exploded_df['genre'].value_counts().reset_index()
        genre_counts.columns = ['genre', 'count']
        fig = px.bar(genre_counts, x='genre', y='count', title='Genre Distribution')
        return fig, {'display': 'block'}

    elif angle == 'platform':
        # 分类处理和柱状图制作 - Platform
        filtered_df['platform'] = filtered_df['platform'].str.split(', ')
        exploded_df = filtered_df.explode('platform')
        specified_platforms = ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
        exploded_df['platform'] = exploded_df['platform'].apply(lambda x: x if x in specified_platforms else 'Others')
        platform_counts = exploded_df['platform'].value_counts().reset_index()
        platform_counts.columns = ['platform', 'count']
        fig = px.bar(platform_counts, x='platform', y='count', title='Platform Distribution')
        return fig, {'display': 'block'}

    return {}, {'display': 'none'}  # 如果未选择有效的 angle，不显示图表



@app.callback(
    [Output('top-details', 'children'),
     Output('top-details', 'style')],
    [Input('angle-selector', 'value'),
     Input('distribution-bar-chart', 'clickData'),
     Input('upload-data', 'contents'),
     Input('metric-selector', 'value')],
    prevent_initial_call=True
)
def display_top_details_by_selection(angle, clickData, contents, metric):
    ctx = dash.callback_context

    if not ctx.triggered or contents is None:
        # 如果没有触发器或者内容为空，则提示用户上传数据
        return 'Upload data to see the top developer.'

    # 判断是哪个输入触发了回调
    trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # 处理上传的数据
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # 根据触发器和angle的值确定显示哪个开发者
    if trigger_id == 'angle-selector' or trigger_id == 'metric-selector':
        default_label = 'Indie' if angle == 'genre' else 'Windows PC'
        clicked_label = default_label
    elif clickData:
        clicked_label = clickData['points'][0]['x']
    else:
        clicked_label = 'Indie'  # 或者根据context设置一个合适的默认值

    required_columns = {'name', 'date', 'genre', 'developer', 'platform', 'rating', 'reviews', 'plays', 'description'}
    if not required_columns.issubset(df.columns):
        return [], {'display': 'none'}

    if clicked_label:
        filter_column = 'genre' if angle == 'genre' else 'platform'
        specified = {
            'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
            'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
        }
        specified_values = specified[angle]

        if clicked_label == 'Others':
            filtered_data = df[~df[filter_column].isin(specified_values)]
        else:
            filtered_data = df[df[filter_column] == clicked_label]
        
        # 检查 filtered_data 是否为空
        if not filtered_data.empty:
            top_items = filtered_data.nlargest(5, metric)
        else:
            return [], {'display': 'none'}  # 如果过滤后没有数据，返回隐藏样式
    else:
        return [], {'display': 'none'}  # 如果没有 clicked_label，返回隐藏样式

    children = [html.H4(f"🥳   Top 5 Games in '{clicked_label}' by {metric.capitalize()}", style={'marginTop':'10px'})]
    for _, row in top_items.iterrows():
        item_details = html.Div([
            html.H5(row['name']),
            html.P(f"Date: {row.get('date', 'Not available')}"),
            html.P(f"Genre: {row.get('genre', 'Not available')}"),
            html.P(f"Developer: {row.get('developer', 'Not available')}"),
            html.P(f"Platform: {row.get('platform', 'Not available')}"),
            html.P(f"Rating: {row.get('rating', 'Not available')}"),
            html.P(f"Reviews: {row.get('reviews', 'Not available')}"),
            html.P(f"Plays: {row.get('plays', 'Not available')}"),
            html.P(f"Description: {row.get('description', 'No description available.')}")
        ], style={'margin': '10px','marginTop': '20px', 'padding': '10px', 'border-radius': '1rem', 'backgroundColor': 'white'})
        children.append(item_details)

    return children, {'display': 'block'}




@app.callback(
    [Output('distribution-metrics-chart', 'figure'),
     Output('distribution-metrics-chart', 'style')],
    [Input('angle-selector', 'value'),
     Input('metric-selector', 'value'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('upload-data', 'contents')]
)
def update_metrics_chart(angle, metric, start_date, end_date, contents):
    if contents is None or not metric or metric not in ['plays', 'rating', 'reviews']:
        return {}, {'display': 'none'}  # 隐藏图表

    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    df['date'] = pd.to_datetime(df['date'])
    filtered_df = df[(df['date'] >= pd.to_datetime(start_date)) & (df['date'] <= pd.to_datetime(end_date))]

    specified_categories = {
        'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
        'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
    }

    filter_column = 'genre' if angle == 'genre' else 'platform'
    specified = specified_categories[filter_column]

    filtered_df[filter_column] = filtered_df[filter_column].str.split(', ')
    exploded_df = filtered_df.explode(filter_column)
    exploded_df[filter_column] = exploded_df[filter_column].apply(lambda x: x if x in specified else 'Others')

    metric_data = exploded_df.groupby(filter_column)[metric].mean().reset_index()
    metric_data.columns = [filter_column, f'average_{metric}']

    # 计算排名并添加一个新列以指示前三名
    metric_data['Top 3'] = metric_data[f'average_{metric}'].rank(ascending=False) <= 3

    # 使用条件颜色设置突出显示前三名
    fig = px.bar(metric_data, x=filter_column, y=f'average_{metric}', 
                 title=f'Average {metric.capitalize()} by {angle.capitalize()}',
                 color='Top 3',
                 color_discrete_map={True: 'rgb(255, 215, 0)', False: 'rgb(101, 110, 242)'}  # Gold for top 3, light blue for others
                 )
    fig.for_each_trace(lambda t: t.update(name = 'Top 3' if t.name == 'True' else 'Others'))

    return fig, {'display': 'block'}

    
    



@app.callback(
    Output('unique-developers-output', 'children'),
    [Input('distribution-bar-chart', 'clickData'),
     Input('angle-selector', 'value'),
     Input('upload-data', 'contents')],
    prevent_initial_call=True
)
def display_unique_developers_by_selection(clickData, angle, contents):
    # 如果没有上传数据，则不更新
    ctx = dash.callback_context

    if not ctx.triggered or contents is None:
        # 如果没有触发器或者内容为空，则提示用户上传数据
        return 'Upload data to see the top developer.'

    # 判断是哪个输入触发了回调
    trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # 处理上传的数据
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # 根据触发器和angle的值确定显示哪个开发者
    if trigger_id == 'angle-selector':
        # 如果是 angle-selector 触发的，使用默认标签
        default_label = 'Indie' if angle == 'genre' else 'Windows PC'
        clicked_label = default_label
    else:
        # 否则，使用 clickData 中的信息
        clicked_label = clickData['points'][0]['x'] if clickData else 'Indie'

    # 过滤得到相应的数据
    df_filtered = filter_data(df, clicked_label, angle)

    # 计算唯一开发者的数量
    unique_developers = df_filtered['developer'].nunique()

    # 构建输出显示的内容
    return html.Div([
        html.H3(f"💻   Number of Developers under '{clicked_label}':", style={'fontSize': '16px', 'fontWeight': 'bold', 'color':'white'}),
        html.P(f"{unique_developers}", style={'fontSize': '24px', 'marginTop': '10px', 'fontWeight': 'bold', 'color':'white'})
    ])

def filter_data(df, label, filter_column):
    # 根据给定的列和标签筛选数据，处理 'Others' 选项
    specified = {
        'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
        'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
    }
    if label == 'Others':
        df_filtered = df[~df[filter_column].str.contains('|'.join(specified[filter_column]), na=False)]
    else:
        df_filtered = df[df[filter_column].str.contains(label, na=False)]
    
    return df_filtered


@app.callback(
    Output('top-developer-output', 'children'),
    [Input('distribution-bar-chart', 'clickData'),
     Input('angle-selector', 'value'),
     Input('upload-data', 'contents')],
    prevent_initial_call=True
)
def display_top_developer_by_selection(clickData, angle, contents):
    ctx = dash.callback_context

    if not ctx.triggered or contents is None:
        # 如果没有触发器或者内容为空，则提示用户上传数据
        return 'Upload data to see the top developer.'

    # 判断是哪个输入触发了回调
    trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # 处理上传的数据
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # 根据触发器和angle的值确定显示哪个开发者
    if trigger_id == 'angle-selector':
        # 如果是 angle-selector 触发的，使用默认标签
        default_label = 'Indie' if angle == 'genre' else 'Windows PC'
        clicked_label = default_label
    else:
        # 否则，使用 clickData 中的信息
        clicked_label = clickData['points'][0]['x'] if clickData else 'Indie'

    # 根据 angle 设置默认点击标签
    specified_categories = {
        'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
        'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
    }
    filter_column = 'genre' if angle == 'genre' else 'platform'
    specified = specified_categories[filter_column]

    if clicked_label == 'Others':
        df_filtered = df[~df[filter_column].str.contains('|'.join(specified), na=False)]
    else:
        df_filtered = df[df[filter_column].str.contains(clicked_label, na=False)]

    developer_counts = df_filtered['developer'].value_counts().reset_index()
    developer_counts.columns = ['developer', 'count']

    if not developer_counts.empty:
        top_developer = developer_counts.iloc[0]['developer']
        top_developer_games_count = developer_counts.iloc[0]['count']
        return html.Div([
            html.H4(f"🏆     Top Developers under '{clicked_label}' {angle}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
            html.P(f"{top_developer} ({top_developer_games_count} games)", style={'fontSize': '20px', 'marginTop': '10px', 'fontWeight': 'bold'})
        ])
    else:
        return f"No games found in the '{clicked_label}' {angle}."






    
# 确保你的布局中有以下元素：
# dcc.Graph(id='distribution-bar-chart'),
# html.Div(id='top-developer-metric-output'),
# dcc.Dropdown(id='angle-selector'),
# dcc.Dropdown(id='metric-selector'),

@app.callback(
    Output('top-developer-metric-output', 'children'),
    [Input('distribution-bar-chart', 'clickData'),
     Input('angle-selector', 'value'),
     Input('metric-selector', 'value'),
     Input('upload-data', 'contents')],
    prevent_initial_call=True
)
def display_top_developers_metric(clickData, angle, metric, contents):
    ctx = dash.callback_context

    if not ctx.triggered or contents is None:
        # 如果没有触发器或者内容为空，则提示用户上传数据
        return 'Upload data to see the top developer.'

    # 判断是哪个输入触发了回调
    trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # 处理上传的数据
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))

    # 根据触发器和angle的值确定显示哪个开发者
    if trigger_id == 'angle-selector' or trigger_id == 'metric-selector':
        default_label = 'Indie' if angle == 'genre' else 'Windows PC'
        clicked_label = default_label
    elif clickData:
        clicked_label = clickData['points'][0]['x']
    else:
        clicked_label = 'Indie'  # 或者根据context设置一个合适的默认值

    # 根据选择的角度设置默认标签
    specified_categories = {
        'genre': ['Indie', 'Adventure', 'Simulator', 'RPG', 'Strategy', 'Shooter', 'Puzzle', 'Arcade'],
        'platform': ['Windows PC', 'Mac', 'Nintendo Switch', 'PlayStation 4', 'Linux', 'iOS', 'Xbox One', 'Android']
    }

    # 根据角度选择器的值筛选数据
    filter_column = 'genre' if angle == 'genre' else 'platform'
    specified = specified_categories[filter_column]

    if clicked_label == 'Others':
        df_filtered = df[~df[filter_column].str.contains('|'.join(specified), na=False)]
    else:
        df_filtered = df[df[filter_column].str.contains(clicked_label, na=False)]

    # 计算每个开发者的平均metric值
    if metric in ['plays', 'rating', 'reviews']:
        developer_metric_avg = df_filtered.groupby('developer')[metric].mean().reset_index()
        developer_metric_avg.columns = ['developer', f'average_{metric}']
        developer_metric_avg.sort_values(by=f'average_{metric}', ascending=False, inplace=True)


        # 创建滚动容器并添加每个开发者的详细信息
        children = html.Div(
            [
                html.Div(
                    [
                        html.H4(
                            f"🎉   Top Developers in '{clicked_label}' by Average {metric.capitalize()}:",
                            style={
                                'fontSize': '16px',  # Larger font size for heading
                                'fontWeight': 'bold',
                                'color': '#5e72e4',  # Matching the primary color theme
                                'marginTop':'15px',
                                'marginBottom': '15px',  # Spacing between the header and list
                                'padding': '10px',  # Padding around the text for better spacing
                                'backgroundColor': '#f8f9fa',  # Light background for the header
                                'borderRadius': '5px',  # Rounded corners for the header
                                'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)'  # Subtle shadow for depth
                            }
                        ),
                        html.Ul(
                            [
                                html.Li(
                                    f"{row['developer']}: {row[f'average_{metric}']:.2f}", 
                                    style={
                                        'fontSize': '16px',  # Uniform font size for list items
                                        'color': '#343a40',  # Darker text for readability
                                        'padding': '5px',  # Padding for list items
                                        'borderBottom': '1px solid #e9ecef',  # Divider between items
                                        'last-child': {'border': 'none'}  # Remove border for the last item
                                    }
                                ) for _, row in developer_metric_avg.head(5).iterrows()
                            ],
                            style={
                                'listStyleType': 'none',  # Remove bullets from the list
                                'margin': '0',  # Remove default margin
                                'maxHeight': '250px',  # Limit the height of the list
                                'overflowY': 'auto',  # Allow scrolling within the list
                                'backgroundColor': '#ffffff',  # White background for the list
                                'borderRadius': '5px',  # Rounded corners for the list
                                'boxShadow': '0 2px 4px rgba(0, 0, 0, 0.1)',  # Subtle shadow for depth
                            }
                        )
                    ],
                    style={
                        'padding': '10px',  # Padding around the entire component
                        'backgroundColor': 'rgba(94, 114, 228, 0.5)',  # Semi-transparent primary color background
                        'borderRadius': '5px',  # Rounded corners for the outer div
                        'boxShadow': '0 4px 8px rgba(0, 0, 0, 0.2)',  # Shadow for the outer div
                        'height': '303px', 
                        "justify-content": "center", "align-items": "center"
                    }
                )

            ],
            style={'display': 'block'}
        )
    else:
        children = f"No valid metric selected."

    return children




import numpy as np
import pandas as pd
import plotly.express as px
from dash import Dash, html, dcc, Input, Output, callback  # 根据您的Dash版本，导入方式可能略有不同

# 假设以下是您Dash应用的一部分







if __name__ == '__main__':
    app.run_server(debug=True)
